<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vai Dar Mar√©!</title>
    <!-- Carrega o Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define a fonte Inter e fallback */
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
        }
        /* Estilos personalizados para a interface */
        .tide-card {
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-radius: 0.75rem; /* Canto arredondado */
        }
        .tide-card:hover {
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            transform: translateY(-3px);
        }
        /* Estilos Tem√°ticos de Mar√© */
        .high-tide {
            border-left: 5px solid #1d4ed8; /* Azul Escuro */
            background-color: #e0f2fe; /* Azul muito claro */
        }
        .low-tide {
            border-left: 5px solid #f97316; /* Laranja V√≠vido */
            background-color: #fff7ed; /* Amarelo muito claro */
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
</head>
<!-- Novo fundo com gradiente tem√°tico -->
<body class="bg-gradient-to-br from-blue-50 to-cyan-100 flex flex-col items-center p-4">

    <!-- Modal de Entrada de Localiza√ß√£o (Estilo aprimorado) -->
    <div id="location-modal" class="fixed inset-0 bg-black bg-opacity-70 z-50 flex items-center justify-center p-4 backdrop-blur-sm">
        <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-lg transform transition duration-300 scale-100 hover:scale-[1.01]">
            <h2 class="text-2xl font-extrabold mb-4 text-blue-700">üìç Vai Dar Mar√©!</h2>
            
            <!-- Conte√∫do de Carregamento/Tentativa Autom√°tica -->
            <div id="auto-location-status" class="text-center p-4 border border-blue-300 bg-blue-50 rounded-lg">
                <p id="auto-message" class="text-blue-700 font-semibold">Tentando obter sua localiza√ß√£o automaticamente...</p>
                <!-- Spinner -->
                <svg id="auto-spinner" class="animate-spin h-6 w-6 mx-auto mt-3 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            </div>

            <!-- Conte√∫do Manual (Fallback) - Inicialmente Oculto -->
            <div id="manual-fallback" class="hidden mt-6">
                <p class="text-gray-600 mb-6">Por favor, insira a Latitude e Longitude manualmente como alternativa:</p>
                <div class="space-y-4">
                    <input type="number" id="lat-input" placeholder="Latitude (Ex: -5.767)" step="0.0001" 
                           class="w-full p-3 border-2 border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150" />
                    <input type="number" id="lon-input" placeholder="Longitude (Ex: -35.2)" step="0.0001" 
                           class="w-full p-3 border-2 border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150" />
                </div>
                
                <button id="fetch-location-btn" 
                        class="mt-6 w-full py-3 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-150 ease-in-out shadow-md shadow-blue-300/50">
                    Buscar Mar√©s Manualmente
                </button>
                <p id="error-message" class="text-red-600 mt-4 hidden text-sm font-medium"></p>
            </div>
        </div>
    </div>

    <!-- Conte√∫do Principal do Aplicativo -->
    <main id="tide-app" class="w-full max-w-4xl opacity-0 transition-opacity duration-500">
        
        <!-- Header aprimorado -->
        <header class="text-center py-8 mb-10 bg-white/95 rounded-3xl shadow-2xl backdrop-blur-sm">
            <h1 class="text-4xl font-extrabold text-blue-700 mb-2">üåä Vai Dar Mar√©!</h1>
            <p class="text-xl text-gray-600 font-medium" id="location-display">Localiza√ß√£o: N/A</p>
        </header>

        <div id="loading-indicator" class="text-center text-blue-600 p-8 hidden">
            <svg class="animate-spin h-8 w-8 mx-auto text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="mt-2 text-lg font-medium">Carregando dados de mar√©...</p>
        </div>
        
        <!-- Layout em grade adapt√°vel para os cart√µes -->
        <div id="tide-results" class="grid grid-cols-1 gap-8">
            <!-- Os resultados de hoje e amanh√£ ser√£o inseridos aqui -->
        </div>

        <div id="error-container" class="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mt-8 rounded-lg hidden">
            <p class="font-bold">Erro na Busca</p>
            <p id="error-details"></p>
        </div>

        <footer class="text-center text-gray-500 text-sm mt-12 pt-6 border-t border-gray-300/50">
            Dados fornecidos por WorldTides.info
        </footer>
    </main>

    <script>
        // Vari√°veis globais
        const API_KEY = 'b2461b1c-0e9e-4c0d-b470-a6cd320534f8';
        const BASE_URL = 'https://www.worldtides.info/api/v3'; 
        
        const MAX_RETRIES = 3;
        const INITIAL_DELAY_MS = 1000;

        // Elementos DOM
        const locationModal = document.getElementById('location-modal');
        const fetchLocationBtn = document.getElementById('fetch-location-btn');
        const latInput = document.getElementById('lat-input');
        const lonInput = document.getElementById('lon-input');
        const errorMessage = document.getElementById('error-message');
        const tideApp = document.getElementById('tide-app');
        const loadingIndicator = document.getElementById('loading-indicator');
        const tideResults = document.getElementById('tide-results');
        const locationDisplay = document.getElementById('location-display');
        const errorContainer = document.getElementById('error-container');
        const errorDetails = document.getElementById('error-details');
        
        // Novos elementos para o estado autom√°tico/manual
        const autoLocationStatus = document.getElementById('auto-location-status');
        const autoMessage = document.getElementById('auto-message');
        const autoSpinner = document.getElementById('auto-spinner');
        const manualFallback = document.getElementById('manual-fallback');

        /**
         * Obt√©m as datas de in√≠cio e fim (hoje + 48h) no formato YYYY-MM-DD.
         */
        const getTideWindowDates = () => {
            const today = new Date();
            
            // Define a data de in√≠cio (hoje √† meia-noite)
            const dateStartObj = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const dateStart = dateStartObj.toISOString().split('T')[0];

            // Define a data de fim (ap√≥s 48 horas, o que cobre hoje e amanh√£)
            const dateEndObj = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 2);
            const dateEnd = dateEndObj.toISOString().split('T')[0];

            return { dateStart, dateEnd };
        };

        /**
         * Formata o Unix timestamp (segundos) para uma string de hora leg√≠vel.
         * @param {number} unixTimestamp - Tempo em segundos desde 1970.
         */
        const formatTime = (unixTimestamp) => {
            // Converte segundos para milissegundos
            const date = new Date(unixTimestamp * 1000); 
            // Op√ß√µes para garantir fuso hor√°rio correto
            const options = { 
                hour: '2-digit', 
                minute: '2-digit', 
                hour12: false 
            };
            return date.toLocaleTimeString('pt-BR', options);
        };
        
        /**
         * Formata o nome do dia da semana a partir de uma string de data (YYYY-MM-DD).
         */
        const formatDay = (dateStr) => {
            // Cria um objeto Date seguro a partir da string 'YYYY-MM-DD'
            const date = new Date(dateStr + 'T00:00:00'); 
            
            const today = new Date();
            const tomorrow = new Date();
            tomorrow.setDate(today.getDate() + 1);

            // Normaliza todas as datas para meia-noite local (dia completo) para compara√ß√£o.
            today.setHours(0, 0, 0, 0);
            tomorrow.setHours(0, 0, 0, 0);
            date.setHours(0, 0, 0, 0); 

            const isToday = date.getTime() === today.getTime();
            const isTomorrow = date.getTime() === tomorrow.getTime();
            
            if (isToday) return 'Hoje';
            if (isTomorrow) return 'Amanh√£';

            const options = { weekday: 'long' };
            return date.toLocaleDateString('pt-BR', options);
        };

        /**
         * Implementa a chamada √† API WorldTides com backoff exponencial para retentativas.
         * @param {string} lat - Latitude.
         * @param {string} lon - Longitude.
         * @returns {Promise<object>} Dados da API.
         */
        const fetchTidesWithRetry = async (lat, lon) => {
            const { dateStart, dateEnd } = getTideWindowDates();
            
            // Inclui 'datum=CD' e 'extremes'
            const url = `${BASE_URL}?datum=CD&extremes&lat=${lat}&lon=${lon}&key=${API_KEY}&date=${dateStart}&date_end=${dateEnd}`;
            
            errorContainer.classList.add('hidden');

            for (let i = 0; i < MAX_RETRIES; i++) {
                try {
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        try {
                            const errorData = await response.json();
                            throw new Error(errorData.error || `Erro de rede: status ${response.status}`);
                        } catch (e) {
                            throw new Error(`O servidor retornou um erro HTTP ${response.status}. Verifique a API Key e o formato da URL. Detalhe: ${e.message}`);
                        }
                    }

                    const data = await response.json();

                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    return data;

                } catch (error) {
                    if (i === MAX_RETRIES - 1) {
                        console.error("Falha ao buscar dados de mar√© ap√≥s retentativas:", error.message);
                        throw new Error(`N√£o foi poss√≠vel carregar as mar√©s. ${error.message}`);
                    }
                    const delay = INITIAL_DELAY_MS * (2 ** i);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        };

        /**
         * Renderiza os dados de mar√© na interface.
         * @param {object} data - Dados da API WorldTides.
         * @param {string} lat - Latitude utilizada.
         * @param {string} lon - Longitude utilizada.
         */
        const displayTides = (data, lat, lon) => {
            const extremes = data.extremes || []; 
            
            tideResults.innerHTML = '';
            locationDisplay.textContent = `Localiza√ß√£o: Lat ${lat}, Lon ${lon}`;
            
            if (extremes.length === 0) {
                tideResults.innerHTML = `
                    <div class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 rounded-lg">
                        <p class="font-bold">Sem dados de Mar√©</p>
                        <p>N√£o foram encontrados dados de mar√© para hoje e amanh√£ nesta localiza√ß√£o. Tente ajustar os valores de Latitude e Longitude, ou se certifique de que a localiza√ß√£o est√° pr√≥xima ao oceano.</p>
                    </div>
                `;
                return;
            }

            // Agrupa as mar√©s por data
            const tidesByDate = extremes.reduce((acc, tide) => {
                // Verifica√ß√£o de seguran√ßa para garantir que dt √© um n√∫mero v√°lido
                if (typeof tide.dt !== 'number' || isNaN(tide.dt)) {
                    console.warn('Evento de mar√© ignorado: timestamp (dt) inv√°lido.', tide);
                    return acc;
                }
                
                // Converte o Unix timestamp (segundos) para uma string de data (YYYY-MM-DD)
                const dateObj = new Date(tide.dt * 1000);
                const date = dateObj.toISOString().split('T')[0];
                
                if (!acc[date]) {
                    acc[date] = [];
                }
                acc[date].push(tide);
                return acc;
            }, {});

            // Ordena as datas e renderiza
            Object.keys(tidesByDate).sort().forEach(date => {
                const dayTides = tidesByDate[date];
                
                // Cria um objeto Date seguro para formata√ß√£o de data local
                const dateForFormatting = new Date(date + 'T00:00:00');
                
                const dateLabel = dateForFormatting.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
                const dayName = formatDay(date);

                const dateSection = document.createElement('section');
                dateSection.className = 'bg-white p-6 rounded-xl shadow-lg mb-8';
                
                dateSection.innerHTML = `
                    <h2 class="text-2xl font-bold mb-4 border-b pb-2 text-gray-700">${dayName}, ${dateLabel}</h2>
                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4" id="tides-${date}">
                        <!-- Cart√µes de mar√© para o dia -->
                    </div>
                `;
                
                tideResults.appendChild(dateSection);

                const dayTidesContainer = dateSection.querySelector(`#tides-${date}`);

                dayTides.forEach(tide => {
                    // Verifica√ß√£o de seguran√ßa para garantir que a altura √© um n√∫mero
                    if (typeof tide.height !== 'number') {
                        console.warn('Dados de altura de mar√© inv√°lidos:', tide);
                        return; // Pula este item se a altura n√£o for um n√∫mero
                    }
                    
                    const isHigh = tide.type === 'high';
                    
                    // Determina√ß√£o de texto de tipo de mar√© e √≠cone
                    let typeText; 
                    let icon;

                    if (tide.type === 'high') {
                        typeText = 'Mar√© Alta';
                        icon = '‚¨ÜÔ∏è'; // Seta para cima
                    } else if (tide.type === 'low') {
                        typeText = 'Mar√© Baixa';
                        icon = '‚¨áÔ∏è'; // Seta para baixo
                    } else {
                         // Fallback - o que n√£o deveria ocorrer com 'extremes'
                        typeText = tide.type ? tide.type.charAt(0).toUpperCase() + tide.type.slice(1) : 'Evento';
                        icon = '„Ä∞Ô∏è'; 
                    }

                    const typeClass = isHigh ? 'high-tide' : 'low-tide';
                    
                    // Usa Math.abs() para garantir que a altura seja sempre POSITIVA (coluna d'√°gua)
                    const displayHeight = Math.abs(tide.height).toFixed(2);

                    const card = document.createElement('div');
                    card.className = `tide-card p-4 rounded-lg ${typeClass} flex flex-col justify-between`;
                    card.innerHTML = `
                        <p class="text-sm font-semibold text-gray-600 mb-1">${typeText}</p>
                        <div class="flex items-center justify-between">
                            <!-- Passa o Unix timestamp (tide.dt) para formatTime -->
                            <span class="text-3xl font-extrabold text-gray-900">${formatTime(tide.dt)}</span>
                            <span class="text-3xl">${icon}</span>
                        </div>
                        <p class="text-base text-gray-700 mt-2">
                            Altura: <span class="font-bold">${displayHeight}m</span>
                        </p>
                    `;
                    dayTidesContainer.appendChild(card);
                });
            });

            // Mostra o conte√∫do principal
            tideApp.classList.remove('opacity-0');
        };
        
        /**
         * Fun√ß√£o central para buscar e exibir os dados de mar√©, ap√≥s obter as coordenadas.
         */
        const handleFetchAndDisplay = async (lat, lon) => {
            // Esconde o modal, mostra o loading principal
            locationModal.classList.add('hidden');
            loadingIndicator.classList.remove('hidden');
            tideApp.classList.add('opacity-0');
            tideResults.innerHTML = '';
            errorContainer.classList.add('hidden');

            try {
                const tideData = await fetchTidesWithRetry(lat, lon);
                displayTides(tideData, lat, lon);
            } catch (error) {
                console.error("Erro final:", error);
                loadingIndicator.classList.add('hidden');
                tideApp.classList.remove('opacity-0'); 
                errorDetails.textContent = error.message;
                errorContainer.classList.remove('hidden');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        };

        /**
         * Tenta obter a localiza√ß√£o do navegador (autom√°tico).
         */
        const tryAutomaticGeolocation = () => {
            if ("geolocation" in navigator) {
                // Exibe o modal e o status de tentativa autom√°tica
                locationModal.classList.remove('hidden');
                autoLocationStatus.classList.remove('hidden');
                manualFallback.classList.add('hidden');
                autoMessage.classList.remove('text-red-700');
                autoMessage.classList.add('text-blue-700');
                autoMessage.textContent = 'Tentando obter sua localiza√ß√£o automaticamente...';
                autoSpinner.classList.remove('hidden');

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        // Sucesso: busca os dados e esconde o modal
                        const lat = position.coords.latitude;
                        const lon = position.coords.longitude;
                        handleFetchAndDisplay(lat.toFixed(4), lon.toFixed(4));
                    },
                    (error) => {
                        // Erro (Usu√°rio negou ou outro erro de GPS)
                        console.warn('Erro na Geolocation:', error.code, error.message);
                        
                        let msg = 'N√£o foi poss√≠vel obter a localiza√ß√£o autom√°tica.';
                        if (error.code === 1) {
                            msg = 'Acesso √† localiza√ß√£o negado pelo usu√°rio. Por favor, insira manualmente.';
                        } else if (error.code === 2) {
                            msg = 'Localiza√ß√£o indispon√≠vel ou falha na rede. Insira manualmente.';
                        } else {
                            msg = 'Ocorreu um erro desconhecido. Insira manualmente.';
                        }
                        
                        // Exibe a mensagem de erro e o fallback manual
                        autoMessage.textContent = `‚ùå ${msg}`;
                        autoMessage.classList.remove('text-blue-700');
                        autoMessage.classList.add('text-red-700');
                        autoSpinner.classList.add('hidden');
                        
                        // Mostra os campos manuais como fallback
                        manualFallback.classList.remove('hidden');
                        
                        // Garante que o modal permane√ßa aberto para a entrada manual
                        locationModal.classList.remove('hidden');
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 5000,
                        maximumAge: 0
                    }
                );
            } else {
                // Geolocation n√£o √© suportada
                autoMessage.textContent = '‚ùå Geolocation n√£o suportada no seu navegador. Use a entrada manual.';
                autoMessage.classList.remove('text-blue-700');
                autoMessage.classList.add('text-red-700');
                autoSpinner.classList.add('hidden');
                manualFallback.classList.remove('hidden');
                locationModal.classList.remove('hidden');
            }
        };

        /**
         * Manipulador para a entrada manual (Fallback).
         */
        const handleManualFetch = async () => {
            const lat = latInput.value.trim();
            const lon = lonInput.value.trim();
            
            errorMessage.classList.add('hidden');
            
            // Valida√ß√£o simples
            if (lat === '' || lon === '') {
                errorMessage.textContent = 'Por favor, preencha a Latitude e a Longitude.';
                errorMessage.classList.remove('hidden');
                return;
            }

            const parsedLat = parseFloat(lat);
            const parsedLon = parseFloat(lon);

            if (isNaN(parsedLat) || isNaN(parsedLon) || parsedLat < -90 || parsedLat > 90 || parsedLon < -180 || parsedLon > 180) {
                errorMessage.textContent = 'Valores de Latitude/Longitude inv√°lidos.';
                errorMessage.classList.remove('hidden');
                return;
            }
            
            handleFetchAndDisplay(parsedLat.toFixed(4), parsedLon.toFixed(4));
        };

        // Adiciona o evento ao bot√£o (manual)
        fetchLocationBtn.addEventListener('click', handleManualFetch);

        // Opcional: Permite enviar pressionando Enter nos campos
        latInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleManualFetch(); });
        lonInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleManualFetch(); });

        // Inicia a tentativa autom√°tica de localiza√ß√£o ao carregar
        window.onload = tryAutomaticGeolocation;

    </script>
</body>
</html>
